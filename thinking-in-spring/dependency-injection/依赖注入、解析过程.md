### 注入过程

### 解析依赖过程

##### 解析依赖入口

```java
// class: org.springframework.beans.factory.support.DefaultListableBeanFactory

public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
      @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

   descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
    // 处理 Optional 类型依赖
   if (Optional.class == descriptor.getDependencyType()) {
      return createOptionalDependency(descriptor, requestingBeanName);
   }
    // 处理 ObjectFactory 或 ObjectProvider 依赖
   else if (ObjectFactory.class == descriptor.getDependencyType() ||
         ObjectProvider.class == descriptor.getDependencyType()) {
      return new DependencyObjectProvider(descriptor, requestingBeanName);
   }
    // TODO
   else if (javaxInjectProviderClass == descriptor.getDependencyType()) {
      return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);
   }
   else {
        // 处理延迟依赖
      Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
            descriptor, requestingBeanName);
      if (result == null) {
        // 处理普通依赖
         result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
      }
      return result;
   }
}

```

###### 普通依赖

> 普通依赖核心入口


```java 
// class: org.springframework.beans.factory.support.DefaultListableBeanFactory

public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,
      @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

   InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);
   try {
      Object shortcut = descriptor.resolveShortcut(this);
      if (shortcut != null) {
         return shortcut;
      }

      Class<?> type = descriptor.getDependencyType();
        // 1
      Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
      if (value != null) {
         if (value instanceof String) {
            String strVal = resolveEmbeddedValue((String) value);
            BeanDefinition bd = (beanName != null && containsBean(beanName) ?
                  getMergedBeanDefinition(beanName) : null);
            value = evaluateBeanDefinitionString(strVal, bd);
         }
         TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
         try {
            return converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());
         }
         catch (UnsupportedOperationException ex) {
            // A custom TypeConverter which does not support TypeDescriptor resolution...
            return (descriptor.getField() != null ?
                  converter.convertIfNecessary(value, type, descriptor.getField()) :
                  converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));
         }
      }
        // 2
      Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
      if (multipleBeans != null) {
         return multipleBeans;
      }
        // 3
      Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
      if (matchingBeans.isEmpty()) {
         if (isRequired(descriptor)) {
            raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
         }
         return null;
      }

      String autowiredBeanName;
      Object instanceCandidate;

      if (matchingBeans.size() > 1) {
         autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);
         if (autowiredBeanName == null) {
            if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {
               return descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);
            }
            else {
               // In case of an optional Collection/Map, silently ignore a non-unique case:
               // possibly it was meant to be an empty collection of multiple regular beans
               // (before 4.3 in particular when we didn't even look for collection beans).
               return null;
            }
         }
         instanceCandidate = matchingBeans.get(autowiredBeanName);
      }
      else {
         // We have exactly one match.
         Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();
         autowiredBeanName = entry.getKey();
         instanceCandidate = entry.getValue();
      }

      if (autowiredBeanNames != null) {
         autowiredBeanNames.add(autowiredBeanName);
      }
      if (instanceCandidate instanceof Class) {
        // 4,内部实际调用是 beanFactory.getBean(beanName);
         instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);
      }
      Object result = instanceCandidate;
      if (result instanceof NullBean) {
         if (isRequired(descriptor)) {
            raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
         }
         result = null;
      }
      if (!ClassUtils.isAssignableValue(type, result)) {
         throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());
      }
      return result;
   }
   finally {
      ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);
   }
}
```

1.获取推荐值，不为 null 则返回

2.解析多个bean，不为 null 则返回

- 2.1 注入对象类型为集合，见第 5 段
- 2.2 非集合返回 null，进行单个查找，见第 3 段
    
3.单个查找自动注入候选

- 3.1 通过 BeanFactoryUtils.beanNamesForTypeIncludingAncestors 层级查找所有候选 bean name
- 3.2 判断依赖类是否是容器
- 3.3 判断所有候选名称是否是自引用，是否是注入候选者
- 3.4 将候选者加入到集合中
    
4.根据候选者名称与类型从容器中获取 bean 实例

```java
// class: org.springframework.beans.factory.support.DefaultListableBeanFactory

protected Map<String, Object> findAutowireCandidates(
      @Nullable String beanName, Class<?> requiredType, DependencyDescriptor descriptor) {

    // 3.1
   String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
         this, requiredType, true, descriptor.isEager());
    // 3.2
   Map<String, Object> result = new LinkedHashMap<>(candidateNames.length);
   for (Map.Entry<Class<?>, Object> classObjectEntry : this.resolvableDependencies.entrySet()) {
      Class<?> autowiringType = classObjectEntry.getKey();
      if (autowiringType.isAssignableFrom(requiredType)) {
         Object autowiringValue = classObjectEntry.getValue();
         autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);
         if (requiredType.isInstance(autowiringValue)) {
            result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);
            break;
         }
      }
   }
    // 3.3
   for (String candidate : candidateNames) {
      if (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, descriptor)) {
         addCandidateEntry(result, candidate, descriptor, requiredType);
      }
   }
   if (result.isEmpty()) {
      boolean multiple = indicatesMultipleBeans(requiredType);
      // Consider fallback matches if the first pass failed to find anything...
      DependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch();
      for (String candidate : candidateNames) {
         if (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, fallbackDescriptor) &&
               (!multiple || getAutowireCandidateResolver().hasQualifier(descriptor))) {
            addCandidateEntry(result, candidate, descriptor, requiredType);
         }
      }
      if (result.isEmpty() && !multiple) {
         // Consider self references as a final pass...
         // but in the case of a dependency collection, not the very same bean itself.
         for (String candidate : candidateNames) {
            if (isSelfReference(beanName, candidate) &&
                  (!(descriptor instanceof MultiElementDescriptor) || !beanName.equals(candidate)) &&
                  isAutowireCandidate(candidate, fallbackDescriptor)) {
               addCandidateEntry(result, candidate, descriptor, requiredType);
            }
         }
      }
   }
   return result;
}
```
5.如果是集合

- 5.1 依赖描述是 StreamDependencyDescriptor
- 5.2 数组
- 5.3 Collection
    + 属性类型必须是接口，否则会报错 org.springframework.beans.factory.UnsatisfiedDependencyException
- 5.4 Map

代码略，核心逻辑也是调用 DefaultListableBeanFactory#findAutowireCandidates 方法获取多个 bean

###### 延迟依赖
1.判断是否延迟

- 1.1 属性依赖
    + 1.1.1 判断属性的注解元信息中是否包含 @Lazy 注解
- 1.2 方法依赖
    + 1.2.1判断方法是否被依赖
    + 1.2.2 判断方法的注解元信息中是否包含 @Lazy 注解
    
```java
// class: org.springframework.context.annotation.ContextAnnotationAutowireCandidateResolver

protected boolean isLazy(DependencyDescriptor descriptor) {
    // 1.1
   for (Annotation ann : descriptor.getAnnotations()) {
      Lazy lazy = AnnotationUtils.getAnnotation(ann, Lazy.class);
      if (lazy != null && lazy.value()) {
         return true;
      }
   }
    // 1.2
   MethodParameter methodParam = descriptor.getMethodParameter();
   if (methodParam != null) {
      Method method = methodParam.getMethod();
        // 1.2.1
      if (method == null || void.class == method.getReturnType()) {
        // 1.2.2
         Lazy lazy = AnnotationUtils.getAnnotation(methodParam.getAnnotatedElement(), Lazy.class);
         if (lazy != null && lazy.value()) {
            return true;
         }
      }
   }
   return false;
}
```

2.创建代理对象

- 2.1 创建目标源
    + 2.1.1 获取目标的方法实现：使用普通依赖重新注入目标对象
- 2.2 创建代理对象返回

```java
// class: org.springframework.context.annotation.ContextAnnotationAutowireCandidateResolver

protected Object buildLazyResolutionProxy(final DependencyDescriptor descriptor, final @Nullable String beanName) {
   Assert.state(getBeanFactory() instanceof DefaultListableBeanFactory,
         "BeanFactory needs to be a DefaultListableBeanFactory");
   final DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) getBeanFactory();
    // 2.1
   TargetSource ts = new TargetSource() {
      @Override
      public Class<?> getTargetClass() {
         return descriptor.getDependencyType();
      }
      @Override
      public boolean isStatic() {
         return false;
      }
      @Override
      public Object getTarget() {
        // 2.1.1
         Object target = beanFactory.doResolveDependency(descriptor, beanName, null, null);
         if (target == null) {
            Class<?> type = getTargetClass();
            if (Map.class == type) {
               return Collections.emptyMap();
            }
            else if (List.class == type) {
               return Collections.emptyList();
            }
            else if (Set.class == type || Collection.class == type) {
               return Collections.emptySet();
            }
            throw new NoSuchBeanDefinitionException(descriptor.getResolvableType(),
                  "Optional dependency not present for lazy injection point");
         }
         return target;
      }
      @Override
      public void releaseTarget(Object target) {
      }
   };
    // 2.2
   ProxyFactory pf = new ProxyFactory();
   pf.setTargetSource(ts);
   Class<?> dependencyType = descriptor.getDependencyType();
   if (dependencyType.isInterface()) {
      pf.addInterface(dependencyType);
   }
   return pf.getProxy(beanFactory.getBeanClassLoader());
}
```

###### Optional 依赖

    依赖类型是 Optional
    
1. 设置 DependencyDescriptor 的 nestingLevel 为2，DependencyDescriptor#getDependencyType 获得真实类型
2. 参照普通依赖，调用 doResolveDependency 方法，获得 bean 实例
3. 包装到 Optional，返回结果


###### ObjectFactory、ObjectProvider 依赖

    依赖类型是ObjectFactory 或 ObjectProvider 
    
1.设置 DependencyDescriptor 的 nestingLevel 为2

- 如果 DependencyDescriptor#getDependencyType == Optional.class，则设置 optional 属性为true

2.返回 DependencyObjectProvider 对象注入（即返回代理对象，延迟依赖）

3.当调用注入 bean 的方法时，则调用 DependencyObjectProvider 重写的 getBean 方法

- 如果 optional 属性为true，则同 Optional 依赖处理流程
- 否则，则同普通依赖处理流程

